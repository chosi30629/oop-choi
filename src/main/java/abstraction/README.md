# 다형성과 추상화

## 다형성
- 여러(poly) 모습(morph)을 갖는 것

- 객체 지향에서는 한 객체가 여러 타입을 갖는 것
    - 즉 한 객체가 여러 타입의 기능을 제공
    - 타입 상속으로 다형성 구현(하위 타입은 상위 타입도 됨)
- 공통 성질을 뽑아내는 추상화와 관련이 있음
  
## 추상화
- 데이터나 프로세스 등을 의미가 비슷한 개념이나 의미 있는 표현으로 정의하는 과정
- 개념화하거나 표현을 도
- 두 가지 방식의 추상화
    - 특정한 성질, 공통 성질(일반화)
- 특정한 성질이나 공통 성질을 뽑아내는 과정
  
        간단한 예
        - DB 의 USER 테이블 : 아이디, 이름, 이메일 -> 특정한 성질
        - Money 클래스 : 통화, 금액 -> 특정한 성질
        - 프린터 : HP MXXX, 삼성 SL-M2XXX -> 공통 성질
        - GPU : 지포스, 라데온 -> 공통 성질
  
- 서로 다른 구현 추상화(공통 성질)
        
        SCP 로 파일 업로드, HTTP 로 데이터 전송, DB 테이블에 삽입   ->   푸시 발송 요청
  
- 타입 추상화
    - 구현 추상화를 할 때 사용
    - 여러 구현 클래스를 대표하는 상위 타입 도출
        - 흔히 인터페이스 타입으로 추상화(공통 기능 정의, 기능에 대한 의미 제공, 구현은 제공하지 않음, 어떻게 구현할지 알 수 없음)
        - 추상화 타입과 구현은 타입 상속으로 연결
        - 구현하는 클래스(콘트리트(concrete) 클래스)
  
- 추상 타입 사용
    - 추상 타입은 구현을 감춤
        - 기능의 구현이 아닌 의도를 더 잘 드러냄
  
- 추상 타입 사용에 따른 이점
    - 요구 사항 변경에 따라 관련된 코드가 함께 변경되는것에 대한 유연함
    - 예 : 주문취소 기능 시 공통점 도출(SMS 전송, 카카오 알림톡, 이메일 발송)   --추--상--화-->   도출한 추상 타입 사용(통지)
  
- 추상화 결과 : 사용 대상 변경 유연함
  
- 추상화는 의존 대상이 변경하는 시점에 한다.
    - 추상화 -> 추상 타입 증가 -> 복잡도 증가
        - 아직 존재하지 않는 기능에 대한 이른 추상화는 주의(잘못된 추상화 가능성, 복잡도만 증가)
        - 실제 변경 / 확장이 발생할 때 추상화 시도
  
- 추상화를 잘 하려면
    - 구현을 한 이유가 무엇 때문이지 생각해야 함
  
## 개발 시간 증가 이유
- 코드 구조가 길어지고 복잡해짐

    - 새로운 클라우드 추가 시 모든 메서드에 새로운 if 블록 추가
    - 중첩 if-else 는 복잡도 배로 증가
    - if-else 가 많을수록 진척 더딤(어디어디가 수정될 지 신중 모드)
- 관련 코드가 여러 곳에 분산됨
    - 한 기능 처리와 관련된 코드가 여러 메서드에 흩어짐
- 결과적으로, 코드 가독성과 분석 속도 저하
    - 코드 추가에 따른 노동 시간 증가
    - 실수하기 쉽고 이로 인한 불필요한 디버깅 시간 증가
  
## OCP(Open-Closed Principle)
- 개방 폐쇄 원칙

- Open for Expansion       확장에는 열려 있음
    - 기능을 변경하고 확장할 수 있으면서
- Closed for Modification  수정에는 닫혀 있음
    - 기능을 사용하는 코드는 수정하지 않아야 한다.